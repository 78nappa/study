# 認証と認可の違い

## 基本的な違い

| 項目 | 認証（Authentication） | 認可（Authorization） |
|------|----------------------|---------------------|
| 目的 | 本人確認（あなたは誰ですか？） | 権限確認（あなたは何ができますか？） |
| 英語略称 | AuthN | AuthZ |
| 実施順序 | 先に実施 | 後に実施 |

## 認証（Authentication）

### 定義
ユーザーが本人であることを確認するプロセス

### 主な方法
- **パスワード認証**: ユーザー名とパスワード
- **生体認証**: 指紋、顔認証、虹彩認証
- **二要素認証（2FA）**: パスワード + SMSコードなど
- **多要素認証（MFA）**: 2つ以上の認証要素を組み合わせ
- **ワンタイムパスワード（OTP）**: 一度だけ有効なパスワード
- **SSO（シングルサインオン）**: 一度のログインで複数サービスにアクセス
- **証明書認証**: デジタル証明書による認証

### 認証の3要素
1. **知識要素**: パスワード、PIN、秘密の質問
2. **所持要素**: スマートフォン、ICカード、セキュリティキー
3. **生体要素**: 指紋、顔、虹彩、声紋

## 認可（Authorization）

### 定義
認証されたユーザーが特定のリソースやアクションにアクセスする権限があるかを確認するプロセス

### 主な方法
- **ロールベースアクセス制御（RBAC）**: 役割に基づいた権限管理
  - 管理者（Admin）
  - 編集者（Editor）
  - 閲覧者（Viewer）
- **アクセス制御リスト（ACL）**: リソースごとに誰がアクセスできるか定義
- **属性ベースアクセス制御（ABAC）**: ユーザー属性に基づいた動的な権限管理
- **スコープベース**: OAuth などで使用される細かい権限設定

### 権限の粒度
```
粗い ←----------------------------------------→ 細かい
システム全体 > 機能単位 > リソース単位 > フィールド単位
```

## 日常生活の例

### 空港
1. **認証**: パスポートチェック → 本人確認
2. **認可**: 搭乗券チェック → 搭乗権限確認

### 会社のオフィス
1. **認証**: 社員証で入館 → 社員であることを確認
2. **認可**: エレベーターで役員フロアへ → アクセス権限確認

### 図書館
1. **認証**: 会員カード提示 → 会員であることを確認
2. **認可**: 貸出可能冊数チェック → 借りる権限確認

## Webサービスの例

### ブログシステム

#### 認証フロー
```
1. ユーザーがログインフォームにID/パスワード入力
2. サーバーがデータベースで照合
3. 一致すれば認証成功 → セッション/トークン発行
4. 「user123としてログインしました」
```

#### 認可フロー
```
認証済みユーザー: user123（一般ユーザー）

[記事閲覧]
→ ✓ 許可（全ユーザーに開放）

[自分の記事を編集]
→ ✓ 許可（自分の記事は編集可能）

[他人の記事を削除]
→ ✗ 拒否（管理者権限が必要）

[システムの設定を変更]
→ ✗ 拒否（管理者権限が必要）
```

### ECサイト

| アクション | ゲスト | 会員 | プレミアム会員 | 管理者 |
|-----------|--------|------|--------------|--------|
| 商品閲覧 | ✓ | ✓ | ✓ | ✓ |
| 購入 | ✓ | ✓ | ✓ | ✓ |
| レビュー投稿 | ✗ | ✓ | ✓ | ✓ |
| 限定セール | ✗ | ✗ | ✓ | ✓ |
| 商品管理 | ✗ | ✗ | ✗ | ✓ |

## OAuth 2.0 との関係

### OAuth 2.0 = 認可フレームワーク
OAuthは主に**認可**のための仕組みです。
```
ユーザー: 「新しいアプリにGoogleカレンダーへのアクセスを許可」
　　↓
認可（アプリにカレンダーを読む権限を与える）
```

### OpenID Connect = 認証 + 認可
OpenID ConnectはOAuth 2.0の上に構築された認証レイヤーです。  
※認証レイヤー（Authentication Layer）：
システムやアプリケーションのアーキテクチャにおいて、**ユーザー認証機能を担当する層（レイヤー）**のことです。
システム全体を複数の層に分けて設計する「レイヤードアーキテクチャ」の一部として、認証処理を独立した層として扱います。
```
ユーザー: 「Googleアカウントでログイン」
　　↓
1. 認証: ユーザーが誰かを確認（OpenID Connect）
2. 認可: アプリが何にアクセスできるか（OAuth 2.0）
```

## セキュリティのベストプラクティス

### 認証
- 強力なパスワードポリシーを実施  
※パスワードポリシー（Password Policy）；  
安全なパスワードを設定・管理するためのルールや規則のことです。組織やサービスが、アカウントのセキュリティを保つために定める基準です。（文字数や組み合わせなどパスワードの複雑性・禁止事項・有効期限・履歴・アカウントロックアウト等）
- 多要素認証（MFA）を推奨または必須化
- パスワードをハッシュ化して保存（bcrypt、Argon2など）
- アカウントロックアウト機能を実装（規定回数パスワードを間違えるとタイムアウトもしくは管理者による解除を必要とする）
- セッションタイムアウトを設定
- パスワードを平文で保存しない
- 簡単すぎるパスワードを許可しない

### 認可
- 最小権限の原則（必要最小限の権限のみ付与）
- デフォルトで拒否（明示的に許可されたもののみアクセス可）
- すべてのリクエストで権限チェック
- 定期的に権限を見直し
- クライアント側だけで権限チェックしない
- 一度認証したら全てを許可しない

## よくある誤解

### ❌ 誤解1: 「ログインできた = 全ての機能が使える」
→ 認証に成功しても、各機能には個別に認可が必要です。

### ❌ 誤解2: 「管理画面のURLを隠せば安全」
→ URLの隠蔽は「セキュリティ by obscurity」で不十分。適切な認可チェックが必要。

### ❌ 誤解3: 「認証さえしっかりすれば大丈夫」
→ 認証と認可の両方が重要。どちらが欠けてもセキュリティリスクになります。

## 処理フロー
```
リクエスト受信
    ↓
┌─────────────┐
│ 認証チェック │ ← 「誰？」
└─────────────┘
    ↓ 失敗 → 401 Unauthorized
    ↓ 成功
┌─────────────┐
│ 認可チェック │ ← 「何ができる？」
└─────────────┘
    ↓ 失敗 → 403 Forbidden
    ↓ 成功
┌─────────────┐
│ 処理実行     │
└─────────────┘
    ↓
200 OK + レスポンス
```

## HTTPステータスコード

| コード | 意味 | 原因 |
|--------|------|------|
| 401 Unauthorized | 認証失敗 | ログインしていない、トークンが無効 |
| 403 Forbidden | 認可失敗 | ログインはしているが権限がない |

## まとめ

### 覚えておくべきポイント

1. **認証は認可の前提条件**
   - まず誰かを確認してから、その人ができることを決める

2. **両方とも重要**
   - 認証だけでは不十分、認可も適切に実装する必要がある

3. **層別防御**
   - クライアント側とサーバー側の両方でチェック
   - ただしサーバー側が最終的な判断を行う

4. **最小権限の原則**
   - 必要な権限だけを付与し、定期的に見直す

---

## 参考資料

- OAuth 2.0: https://oauth.net/2/
- OpenID Connect: https://openid.net/connect/
- OWASP Authentication Cheat Sheet: https://cheatsheetseries.owasp.org/